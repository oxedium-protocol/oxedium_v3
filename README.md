![Solana](https://img.shields.io/badge/Blockchain-Solana-blue.svg)
![Anchor](https://img.shields.io/badge/Framework-Anchor-orange.svg)
![License](https://img.shields.io/badge/License-SIOL-brightgreen?style=flat-square)
![GitHub stars](https://img.shields.io/github/stars/oxedium-protocol/oxedium?style=social)

# Oxedium

Single-sided liquidity protocol on Solana. Earn trading fees **without impermanent loss** by depositing a single asset into Oxedium vaults.

---

## Overview

Traditional AMMs require paired liquidity deposits and expose providers to impermanent loss. Oxedium separates the two roles completely:

- **Liquidity providers (stakers)** deposit a single token and earn a share of all swap fees generated by that vault.
- **Traders** swap between any two vaults at Pyth oracle prices. Fees are designed to protect vault health and reward providers.

There are no token pairs, no bonding curves, and no impermanent loss — pricing is fully delegated to Pyth oracles.

---

## Protocol Lifecycle

| Action | Participant | Tokens in | Tokens out | State changes |
|--------|-------------|-----------|------------|---------------|
| `staking` | LP | → vault ATA | — | `initial_balance ↑`, `current_balance ↑`, `staked_amount ↑` |
| `swap` | Trader | → vault_in ATA | ← vault_out ATA | `current_balance_in ↑`, `current_balance_out ↓`, `cumulative_yield_per_lp ↑` |
| `claim` | LP | — | ← vault ATA | `current_balance ↓`, `pending_claim = 0` |
| `unstaking` | LP | — | ← vault ATA | `initial_balance ↓`, `current_balance ↓`, exit fee → `cumulative_yield_per_lp ↑` |
| `collect` | Admin | — | ← vault ATA | `current_balance ↓`, `protocol_yield = 0` |

---

## On-Chain Architecture

```
                        ┌──────────────┐
                        │   Admin PDA  │  (authorization only — no funds)
                        └──────────────┘

          ┌─────────────────────────────────────────────┐
          │  Vault PDA (SOL)       Vault PDA (USDC) ... │  one per token mint
          │  ┌─────────────┐       ┌─────────────┐      │
          │  │  vault_ata  │       │  vault_ata  │      │  each vault owns
          │  │  (SOL ATA)  │       │ (USDC ATA)  │      │  its own tokens
          │  └─────────────┘       └─────────────┘      │
          └─────────────────────────────────────────────┘
                 │
        one per staker per vault
                 │
          ┌──────▼──────┐
          │  Staker PDA │   tracks staked amount, pending yield, last checkpoint
          └─────────────┘
```

Each vault is fully self-contained: it holds its own token ATA and signs all outgoing transfers using its PDA seeds `["vault-seed", token_mint]`. The Admin PDA exists only for admin authorization checks — it holds no funds.

### Account types

| Account | Seeds | Stores |
|---------|-------|--------|
| `Admin` | `["oxedium-seed", "admin-seed"]` | Admin pubkey (authorization only) |
| `Vault` | `["vault-seed", token_mint]` | Balances, fee params, cumulative yield, oracle config, token ATA authority |
| `Staker` | `["staker-seed", vault_pda, user]` | Staked amount, last yield checkpoint, claimable rewards |

### Vault state

```rust
pub struct Vault {
    pub base_fee_bps: u64,             // floor fee for swaps out of this vault
    pub protocol_fee_bps: u64,         // portion of swap fee going to the protocol
    pub max_exit_fee_bps: u64,         // maximum exit penalty for LP withdrawals

    pub token_mint: Pubkey,
    pub pyth_price_account: Pubkey,
    pub max_age_price: u64,            // max staleness of oracle data (seconds)

    pub initial_balance: u64,          // total LP-deposited liquidity
    pub current_balance: u64,          // actual token balance (changes with swaps)

    pub cumulative_yield_per_lp: u128, // scaled accumulator for LP fee distribution
    pub protocol_yield: u64,           // accumulated protocol fees awaiting collection
}
```

`initial_balance` tracks total staked capital — it grows on stake and shrinks on unstake. `current_balance` tracks actual tokens in the vault and additionally changes as swaps flow through. The ratio `current_balance / initial_balance` is the vault's **liquidity health indicator**.

---

## Liquidity Providers

### Staking

Deposit tokens → tokens go to the **vault's own ATA** → `staker.staked_amount` increases → both `initial_balance` and `current_balance` increase by the deposited amount.

Before updating the staked amount, any unrealized yield is snapshotted into `pending_claim` using the cumulative yield accumulator so nothing is lost:

```
pending_yield += (cumulative_yield_per_lp − last_checkpoint) × staked_amount / SCALE
```

### Unstaking

Withdraw tokens → **vault PDA signs** and sends tokens from its ATA back to the user → `staked_amount` decreases → both vault balances decrease by the full unstaked amount.

**Dynamic exit fee (quadratic curve):** a graduated fee kicks in as the vault's health deteriorates. Small drawdowns incur a tiny fee; deep drawdowns are penalised aggressively. The fee is distributed to **remaining LP stakers** via `cumulative_yield_per_lp` — not to the protocol — as compensation for the liquidity risk they absorb.

```
health        = current_balance / initial_balance   (0..100 %)
deficit       = 100 − health
curved        = deficit² / 100                      (quadratic 0..100)
exit_fee_bps  = max_exit_fee_bps × curved / 100
```

| Vault health | Exit fee (example: max = 5%) |
|---|---|
| 100 % | 0 bps (0.00 %) |
| 80 % | 20 bps (0.20 %) |
| 50 % | 125 bps (1.25 %) |
| 20 % | 320 bps (3.20 %) |
| 0 % | 500 bps (5.00 %) |

### Claiming yield

Stakers call `claim` to collect accumulated LP fees at any time. The vault PDA signs the transfer from its ATA to the staker. The payout is:

```
claimable = pending_claim + (cumulative_yield_per_lp − last_checkpoint) × staked_amount / SCALE
```

Yield is paid in the **same token as the vault** (e.g., stakers in the USDC vault receive USDC fees). After claiming, `last_cumulative_yield` is updated and `pending_claim` is reset to zero.

---

## Traders (Swaps)

Swaps exchange token A for token B by depositing into vault A (input) and withdrawing from vault B (output). Pricing is entirely oracle-driven with no bonding curve.

### Swap execution

1. **Validate oracle accounts** — Pyth price feed pubkeys are checked against vault config.
2. **Freshness check** — oracle timestamps must not be in the future and must not exceed `max_age_price` seconds of staleness.
3. **Compute swap math** — raw output from oracle prices, then apply composite fee.
4. **Slippage guard** — `net_amount_out ≥ minimum_out` (user-supplied), otherwise revert.
5. **Update vault state** — `vault_in.current_balance += amount_in`, `vault_out.current_balance -= net_amount_out`, LP fee accumulates into `cumulative_yield_per_lp`.
6. **Transfer tokens** — user sends token A to `vault_in` ATA; `vault_pda_out` signs and sends token B from `vault_out` ATA to the user.

### Raw output calculation

Before fees, the output is computed purely from Pyth mid-prices:

```
usd_value = amount_in × price_in  × 10^exponent_in
raw_out   = usd_value / price_out / 10^exponent_out
```

Pyth exponents (typically negative, e.g. `-8`) are handled correctly for both signs to avoid precision loss.

---

## Fee Model

Every swap incurs a **composite fee** applied to `raw_out`. Three independent components are summed. Each serves a distinct economic purpose.

### 1. Imbalance fee

Incentivizes swaps that rebalance the protocol. Measures relative deviation of each vault from its initial balance:

```
delta_in_bps  = (current_in  − initial_in)  × 10_000 / initial_in
delta_out_bps = (current_out − initial_out) × 10_000 / initial_out
```

- If `delta_in ≤ delta_out` → the swap helps rebalance → fee = `base_fee_bps` (floor).
- If `delta_in > delta_out` → the swap stresses the output vault → fee grows on a **quadratic curve**:

```
deviation  = |delta_out|  (capped at 10_000 bps)
curved     = deviation² / 10_000
fee        = base_fee + (10_000 − base_fee) × curved / 10_000
```

| Output vault health | Approximate swap fee |
|---------------------|----------------------|
| Balanced (0% deficit) | `base_fee` (e.g. 30 bps) |
| 25% deficit | ~650 bps |
| 50% deficit | ~2 500 bps |
| 100% drained | 10 000 bps (100%) |

### 2. Oracle confidence fee

Added on top of the imbalance fee. Makes latency arbitrage unprofitable when Pyth uncertainty is high:

```
oracle_fee = (conf_in / price_in + conf_out / price_out) × 10_000   [in bps, capped at 10_000]
```

The entire oracle_fee flows to LPs as direct compensation for oracle-latency risk. It is zero when both oracles report tight confidence intervals and grows during volatile market conditions.

### 3. Liquidity impact fee

Protects the output vault from large single swaps depleting its reserves. Computed from the swap's utilization of the vault:

```
utilization_bps = raw_out × 10_000 / current_balance
```

- Below **10% utilization** → no extra impact, fee = imbalance fee + oracle_fee.
- Above **10% utilization** → quadratic curve grows aggressively toward 100%:

```
adj    = (utilization − 10%) normalised to 0..10_000
curved = adj² / 10_000
fee    = base_imbalance_fee + (10_000 − base_imbalance_fee) × curved / 10_000
```

Examples (base fee = 30 bps):

| Utilization | Liquidity impact fee |
|-------------|----------------------|
| ≤ 10% | 30 bps (no curve) |
| 20% | ~148 bps |
| 50% | ~2 000 bps |
| 70% | ~4 500 bps |
| 100% | 10 000 bps (100%) |

If `current_balance = 0`, the fee jumps directly to 10 000 bps.

### 4. Protocol fee

A flat `protocol_fee_bps` (set per vault, independent of the above) is applied separately. Collected into `vault.protocol_yield` and withdrawn by the admin via `collect`.

### Safety check

```
if (imbalance_fee + oracle_fee + liquidity_fee) + protocol_fee > 10_000 → FeeExceeds error
```

This prevents pathological combinations from producing a negative net output.

### Fee distribution

| Component | Recipient |
|-----------|-----------|
| LP fee (imbalance + oracle + liquidity impact) | Distributed to stakers of the **output vault** via `cumulative_yield_per_lp` |
| Protocol fee | Held in `vault.protocol_yield`, withdrawn by admin via `collect` (vault PDA signs) |
| Exit fee (on unstaking) | Distributed to **remaining LP stakers** of the same vault via `cumulative_yield_per_lp` |

---

## Cumulative Yield Mechanism

Oxedium uses an **accumulator pattern** to distribute LP fees fairly without iteration over all stakers:

```
// on every swap
cumulative_yield_per_lp += lp_fee_amount × SCALE / initial_balance
```

`SCALE = 1_000_000_000_000` (10¹²) provides fixed-point precision.

Each staker stores `last_cumulative_yield`. Their share of any time window is:

```
yield = (cumulative_yield_per_lp − last_cumulative_yield) × staked_amount / SCALE
```

This snapshot is taken on every `stake`, `unstake`, and `claim` call, so yield is never lost on position changes.

---

## Instructions

### Admin

| Instruction | Description |
|-------------|-------------|
| `init_admin` | Initialize the Admin PDA (authorization account) |
| `update_admin` | Transfer admin authority to a new pubkey |
| `init_vault` | Create a new vault (`base_fee`, `max_age_price`, `max_exit_fee_bps`) |
| `update_vault` | Update `base_fee_bps`, `protocol_fee_bps`, `max_exit_fee_bps`, oracle config |
| `collect` | Withdraw accumulated protocol yield from a vault (vault PDA signs) |

### Staker

| Instruction | Arguments | Description |
|-------------|-----------|-------------|
| `staking` | `amount: u64` | Deposit tokens into a vault, earn LP fees proportionally |
| `unstaking` | `amount: u64` | Withdraw tokens; quadratic exit fee distributed to remaining LP stakers |
| `claim` | — | Collect all accumulated LP fee rewards |

### Trader

| Instruction | Arguments | Description |
|-------------|-----------|-------------|
| `swap` | `amount_in: u64`, `minimum_out: u64` | Swap tokens between two vaults with slippage protection |

---

## Program ID

```
Not yet deployed on the mainnet
```

---

## Links

- [X (Twitter)](https://x.com/0xedium)
- [Community](https://t.me/oxedium_portal)
- [App](https://oxedium.com)
